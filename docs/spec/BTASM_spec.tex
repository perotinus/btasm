\documentclass[12pt,a4paper]{scrbook}

%
%Header
%
%\usepackage{fancyhdr}
%\setlength{\headheight}{15.2pt}
\usepackage{scrpage2}
\usepackage{listings}
\usepackage{geometry}
\lstset{frame=single, basicstyle=\ttfamily, tabsize=4}
\cfoot{}
\pagestyle{empty}

%\fancyhf{}

%\fancyhead[%\fancyfoot[C]{}


\begin{document}

\title {BTASM language specification}
\date {Revision 0 - April 4, 2012}
\author {Jonathan MacMillan \\(jonathan.macmillan@yale.edu)}
\maketitle

\frontmatter
\setcounter{page}{1}
\tableofcontents


\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}
\pagestyle{scrheadings}
\rohead{\thepage}
\rehead{PREFACE}
\lohead{PREFACE}
\lehead{\thepage}
\cfoot{}
\ofoot{}
%\fancyhead[RO]{\thepage}
%\fancyhead[LO] {PREFACE}
%\fancyhead[RE] {PREFACE}
%\fancyhead[LE]{\thepage}
\section*{Introduction}

Battle Tag is a laser tag system designed and marketed by UbiSoft.  It was released in a
limited market (ie, Texas and Canada) near the end of 2010.  Since then, the system has
not been released in a larger market.  It appears to have been abandoned by UbiSoft shortly
thereafter, and (as of the creation of this document) none of the equipment can be purchased
from UbiSoft's website.

The game itself consists of infra-red "laser" guns, sensor vests, RFID-enabled "bases", and
the UbiConnect, a USB peripheral which communicates with the guns using an unknown radio
technology.  The computer that is connected to the UbiConnect manages all aspects of play 
(except, of course, those that it offloads to the weapons themselves) and is called the Game
Master (henceforth referred to as the GM).

Support for the product seems to be very limited.  The new equipment being sold by other
vendors in what seems to be a liquidation sale comes with a 90-day manufacturer warranty, 
which I have no reason to believe will not be honoured.  Be sure to thoroughly test the
equipment within this 90-day period, as the first sensor vest that I purchased was faulty.
There is no easy way to get the equipment in the United States - 1saleaday has been selling
vests and guns for around \$60 for some time.  The expansion kits are nearly impossible
to find - I could only source them from Amazon Canada, which does not allow importation of
video games to the United States.  


\section*{Purpose}

The purpose of this document is to elucidate the bytecode that is used to control the 
guns during gameplay.  This information has been gleaned from the bytecode and associated
source files provided with the BattleTag software.  Anyone who wishes to obtain this 
software must purchase BattleTag equipment - the software is not available legally (to
my knowledge) save on the CD-ROM that accompanies the game.

Every time a game is initiated, the GM broadcasts a bytecode
to all of the guns that are involved in the game.  This bytecode is stored in Lua tables
as a comma-separated sequence of bytes.  The bytecode appears to be almost completely
responsible for the functioning of the device in game - the full workings of each gameplay
mode appear to be represented in the bytecode files.

UbiSoft has rather oddly chosen to leave the non-assembled source files for all of the
bytecodes in the distributed version of the game.  This golden opportunity has allowed
reverse-engineering the bytecode to take orders of magnitude less time than it would
have otherwise.  The language used seems to be a special language developed in-house at
UbiSoft.  It is a simple event-driven imperative language, with special language features to control
different elements of the weapon.  There is a slight bit of work that the assembler needs 
to do in order to translate between the source code and the bytecode.  In fact, it is very
straightforward to write bytecode and upload it to the device (by hijacking the game's built-in
upload routines).  

There appears to be no CRC or consistency check of any sort on the weapons or the GM.  In fact,
it is perfectly possible to upload broken code to the device.  It appears that simply turning
the device off and on clears the flashed bytecode and returns the device to a factory state.
This, however, has not been thoroughly tested, and it is not recommended that code by written
with the intention of interfering with the actual device firmware (though such modification 
should be possible through editing the GM's Lua files).

The bytecode described here is obviously that used by the weapons.  The canonical BTASM
 language,
however, differs from the UbiSoft-style BTASM.  The BTASM compiler has a flag
(-U) that can parse UbiSoft-style BTASM\footnote{This flag is included mainly for 
testing against UbiSoft-style files}; canonical BTASM is used by default, and should 
be used unless there is a particular reason not to do so.   

This document does not go into detail concerning the code that the GM must run to keep the
game working.  This code varies less than one might expect from game type to game type, and is
mainly concerned with overall control and scoring.  If there is interest, I may cover this
information in another document. 
 
 
\section*{Disclaimer}

The author makes no
guarantee that any of the information presented in this document is accurate.  
Everything in this document is presented on an "as-is" and "with all faults" basis.  The 
author is not liable
for any damage to equipment or persons that is caused by any use, modification, or 
dissemination of the information presented in this document.  You
are solely responsible for determining the applicability and compatibility of this
information with and to your equipment, and for the protection of yourself and your 
equipment.

\section*{Acknowledgements}

Thanks to BL Martech, who alerted me to the fact that the Battle Tag distribution included
Lua source files.  Thanks, also, to the developers at UbiSoft, who left a veritable roadmap for
us to follow.  
All thanks, of course, are given to God, who granted me a mind and a will to better
understand this part of His creation.  May this work glorify Him alone.


\rohead {\thepage}
\lohead {\rightmark}
\rehead {\leftmark}
\lehead {\thepage}

\mainmatter

\chapter{The beginning}

\section{Environment}

BTASM is whitespace-agnostic.  Control structures are defined explicitly, though indentation is
recommended in order to facilitate comprehension of control structures.  BTASM is case-sensitive;
identifiers beginning with an uppercase letter are all reserved.  Variables must begin with a
lowercase letter and can contain alphanumeric charaters and the underscore character.

\subsection{UbiSoft-style}
UbiSoft-style BTASM source files are very simple in nature.  They consist of:
\begin{itemize}
\item A resource block 
\item A variable declaration block
\item Optional function declarations
\item A required initial state
\item Optional additional states
\end{itemize}

These parts of a source file must appear in this order in an UbiSoft-style BTASM file.  
\\\\
The resource block never appears in the Ubisoft-style BTASM files -- it is instead generated from
the rest of the source file and prepended to the beginning of the bytecode.  The resource block is 
a list of all the sound and animation resources that the gun uses for this program.  They appear in
the order of their first appearance in the file, ""but this is not necessary  (is it?).**  
The block is preceded by a byte which lists how many resources there are in this file.  A simple
bytecode may only need three or four sound/animation resources, while a complicated bytecode may use
twenty or thirty.  **While it is possible to use at least twenty, the maximum possible number is 
not known.**  

It is essential to note that, while these resources are represented in the source files with 
particular names that do not vary from file to file, the integer values that represent these 
different resources do vary, depending on the order that they appear in the resource block.  A 
convenient way to think about it is a simple map, where the values are incremented by one each time
a new key is inserted.  Therefore, the particular mapping of the sound DEAD might not be the same 
between two source files, but it will not change within a bytecode file..

The variable declaration block consists of a newline-separated list of variable expressions
which define a variable by name and determine its relationship to the GM.  All variables are 
**32-bit integers** (CHECK THIS).  

By default, all variables are declared as global variables in the scope of the gun program.
The scope of the variable as it relates to the GM can be modified with the following keywords:
\begin{itemize}
\item CONFIG (???)
\item SEND (the variable is sent to the GM in regular updates)???
\item RECEIVE (the variable is sent to the gun from the GM in regular updates)???
\end{itemize}

Variables of the different types can be declared in any order.  No variable can be declared
with more than one attribute type: thus \lstinline|VAR foo SEND, CONFIG| is an invalid
declaration.  All of these variables exist in a global namespace.  There are no limited-scope 
variables.  Variables cannot be declared outside of the variable declaration block.  

\begin{figure}[h]
\begin{lstlisting}
VAR a	SEND
VAR b
VAR c   RECEIVE
VAR d	CONFIG
VAR e	SEND
\end{lstlisting}
\caption{A valid variable block in an UbiSoft-style BTASM program} 
\end{figure}

\ \\

The optional function declarations follow the variable declaration block.  A function definition
consists of a special keyword (FUN) and a name.  There is no separation function declaration - the
function definition serves as the declaration.  Therefore, function declarations *must/should* be
placed at the beginning of the source file/before they are first
used in the program.  **The variable and function name-spaces do not
conflict (THIS NEEDS TO BE TESTED!!)  If no functions are needed, than none need be declared.  Note 
that these functions are decidedly non-functional, since they depend on global values, and neither
accept arguments or return values.  They would be better referred to as procedures -- following the
syntax of the UbiSoft-style language, we will refer to them as functions.


  

\begin{figure}[h]
\begin{lstlisting}
FUN foo
	HUD_ICON_ON BULLET
	HUD_ICON_ON LIFE
END_FUNCTION
\end{lstlisting}
\caption{A valid function definition in an UbiSoft-style BTASM program} 
\end{figure}


Event states are the main drivers of the gun's action.  The control flow of a BTASM program can be
conceptualized as a state machine.  The gun begins the game in an initial state (denoted by 
\texttt{FIRST\_STATE}), in which it responds to environmental stimuli.  At points, the gun can switch
states, and respond differently to the same stimuli.  This paradigm will be familiar to anyone who
has programmed embedded devices.

The possible events that a particular state can respond to are (at least): (nb - check the 
bytecodes to see if there are more)
\begin{itemize}
\item \texttt{ANIM\_FINISHED} - finished HUD animation
\item \texttt{BUTTON\_1\_JUST\_PRESSED} - pressed button below HUD
\item \texttt{BUTTON\_2\_JUST\_PRESSED} - pressed trigger
\item \texttt{BUTTON\_3\_JUST\_PRESSED} - pressed RFID button
\item \texttt{DATA\_CHANGE} - GM has changed a variable declared with the \texttt{RECEIVE} attribute
\item \texttt{ENTER\_STATE} - Code run upon entering a state
\item \texttt{HIT} - hit by another gun
\item \texttt{TIMER} - ??probably responds to end of TIMER that was set earlier
\item \texttt{TICK} - ??do something on each tick of the clock (what clock?)
\end{itemize}

Each of these events, when called, runs a block of code which can do anything that can be done
in a function.  It can \texttt{GOTO} an alternate state; call a function; change variables; or
simply do nothing.  Events cannot be declared more than once per state.

The state namespace does not conflict with the function namespace or the variable namespace.  It is
possible to have a variable named foo, a function named foo, and a state named foo (this is, however,
not recommenced, and the compiler will print a warning if it detects double-naming).

\begin{figure}[h]
\begin{lstlisting}
STATE foo
FIRST_STATE

	EVENT BUTTON_1_JUST_PRESSED
		HUD_ICON_ON BULLET
	END_EVENT

	EVENT BUTTON_3_JUST_PRESSED
		HUD_ICON_OFF BULLET
	END_EVENT

END_STATE
\end{lstlisting}
\caption{A valid state definition in an UbiSoft-style BTASM program} 
\end{figure}

\begin{figure}[h]
\begin{lstlisting}

VAR a SEND
VAR b 

FUN foo
	HUD_ICON_ON BULLET
	HUD_ICON_OFF LIFE
END_FUNCTION

FUN bar
	HUD_ICON_ON LIFE
	HUD_ICON_OFF BULLET
END_FUNCTION
	
STATE baz
FIRST_STATE

	EVENT BUTTON_1_JUST_PRESSED
		foo		--call function foo
	END_EVENT

	EVENT BUTTON_3_JUST_PRESSED
		bar		--call function bar
	END_EVENT

END_STATE
\end{lstlisting}
\caption{A valid UbiSoft-style BTASM program} 
\end{figure}

\chapter{Language definition}
This chapter contains a definition of each of the operations in the BTASM bytecode, along with an
explanation of their operation.  This chapter explains the bare mechanics of the bytecode, not
the syntax and semantics of the associated UbiSoft-style BTASM language.  The author recommends
that people use the proposed canonical syntax that maps more closely between bytecode and language.

\section{Instruction set}

\subsection{Declarations}

\subsubsection{0xcc - VAR [0,1,2,3]} 
Declares a global variable
\begin{itemize}
\item 0 = no attributes
\item 1 = \texttt{SEND}
\item 2 = \texttt{RECEIVE}
\item 3 = \texttt{CONFIG}
\end{itemize}

\subsubsection{0xd0 - FUN [FUNIDX] [INT]}
Declares a function
\begin{itemize}
\item A1 = function identifier (non-repeated ascending integers)
\item A2 = size of function in bytes (maximum value of 256 - not counting declaration)
\end{itemize}
NB - this is an overloaded instruction that is also used for function calls with a different type
signature

\subsubsection{0xd2 - STATE FIRST\_STATE [STATEIDX] [LONGINT]}
Declares a new (initial) state
\begin{itemize}
\item A1 = state identifier (non-repeated ascending integers)
\item A2 = size of the state in bytes (not counting declaration)
\end{itemize}
NB - There can be only one initial state per program.

\subsubsection{0xc7 - STATE [STATEIDX] [LONGINT]}
Declares a new (non-initial) state
\begin{itemize}
\item A1 = state identifier (non-repeated ascending integers)
\item A2 = size of the state in bytes (not counting declaration)
\end{itemize}
NB - Though there are different bytecodes for the initial state and a regular state,
the state identifiers must be unique for each different state.

\subsubsection{[EVENTCODE] - EVENT [EVENTCODE] [INT]}
Declares a new event in a state.
Event types:
\begin{itemize}
\item \texttt{0x00 = BUTTON\_1\_JUST\_PRESSED}
\item \texttt{0x01 = BUTTON\_2\_JUST\_PRESSED}
\item \texttt{0x02 = BUTTON\_3\_JUST\_PRESSED}
\item \texttt{0x09 = TIMER}
\item \texttt{0x0a = TICK}
\item \texttt{0x0b = HIT}
\item \texttt{0x0c = ENTER\_STATE}
\item \texttt{0x0e = ANIM\_FINISHED}
\item \texttt{0x0f = DATA\_CHANGE}
\end{itemize}
The second argument is the length of the event code in bytes (not counting declaration)

\subsection{Control flow}

\subsubsection{0xc3 - GOTO [STATEIDX]}
Switch to a different state.  That state's ENTER\_STATE event will be executed.?????
\begin{itemize}
\item A1 = index in state table to move to
\end{itemize}

\subsubsection{0xc4 - IF [VARIDX] 0x01 [LONGINT] [INT] [IF branch len]...[ELSE branch len]...}
\subsubsection{0xc4 - IF [VARIDX] 0x00 [VARIDX] [INT]...[IF branch len]...[ELSE branch len]...}
Compare two values and branch depending on the result of the comparison.
\begin{itemize}
\item A1 = index in variable table of left-side comparison variable
\item A2 = 0x01 for immediate comparison; 0x00 for variable comparison
\item A3 = immediate value to compare or index to variable to compare with (right side)
\item A4 = comparison function (0 = SUP; 2 = COMP; 3 = DIFF)
\item A5 = length of the IF branch of the conditional
\item A6 = length of the ELSE branch of the conditional (can be 0x00)
\end{itemize}
NB - the two length arguments are placed just before the code that their associated branches contain.
The language has no JMP capabilities, so the IF and ELSE branches must follow the IF instruction.
The ... in the instruction definition represent source code.  There is no need to specify the
ending point of a branch - the length arguments handle the length.

\subsubsection{0xd0 - CALL [FUNIDX]}
Call a function.
\begin{itemize}
\item A1 = index in function table of function to call
\end{itemize}

\subsubsection{0xdd - SET HARNESS [INT]}
Set whether the harness is used or not in this game.
\begin{itemize}
\item A1 = 0 if harness is not used; 1 if harness is used
\end{itemize}

\subsubsection{0xc1 - DEC [VARIDX]}
Decrement a variable.
\begin{itemize}
\item A1 = the index of the variable to decrement
\end{itemize}

\subsubsection{0xc2 - INC [VARIDX]}
Increment a variable
\begin{itemize}
\item A1 = the index of the variable to increment
\end{itemize}

\subsection{0xcd - HUD\_DIGIT [0x01/0x00] [INT/VARIDX] [0x01/0x00]}
Display a digit on the HUD. (between 0 and 19).  
\begin{itemize}
\item A1 = 0 for variable argument; 1 for constant argument
\item A2 = index of variable or immediate value to display
\item A3 = 0 for solid display; 1 for blinking display
\end{itemize}

\subsection{0xd6 - HUD\_DIGIT\_OFF}
Stop displaying a digit on the HUD.


\subsection{0xce - HUD\_JAUGE [0x01/0x00] [INT/VARIDX] [0x01/0x00]}
Display a value on the gauge.  Valid values are between 1 and 6.  Anything greater
than 6 will cause the gauge to display a value of 0.  
\begin{itemize}
\item A1 = 0 for variable argument; 1 for constant argument
\item A2 = index of variable or immediate value to display
\item A3 = 0 for solid display; 1 for blinking display
\end{itemize}

\subsection{0xcb - ANIM [RESIDX]}
Display an animation on the HUD.
\begin{itemize}
\item A1 = the index of the resource to display.  Must be an animation 
\end{itemize}
\subsection{0xdf - ANIM\_OFF}
TODO - what does this do???
Turn off (the????) animation on the HUD.




\subsection{Output}


\section{Constants}
This section contains tables of all of the constants that can appear in BTASM files.
Some of these are mapped directly onto what they represent; others create entries in 
integer-addressed tables that map from integers to the item represented by the bytecode.

\subsection{Animation constants}
\begin{center}
  \begin{tabular}{| c | c || c | }
    \hline
    Source symbol & Table bytecode & Description \\ \hline \hline
    AGB1 & \texttt{0x41, 0x47, 0x42, 0x31, 0x00, 0x00} & ???  \\ \hline
    AGB2 & \texttt{0x41, 0x47, 0x42, 0x32, 0x00, 0x00} & ???  \\ \hline
    AGB3 & \texttt{0x41, 0x47, 0x42, 0x33, 0x00, 0x00} & ???  \\ \hline
    AGB4 & \texttt{0x41, 0x47, 0x42, 0x34, 0x00, 0x00} & ???  \\ \hline
    AMED & \texttt{0x41, 0x4d, 0x45, 0x44, 0x00, 0x00} & ???  \\ \hline
    AOUT & \texttt{0x41, 0x4f, 0x55, 0x54, 0x00, 0x00} & ???  \\ \hline
    ARAM & \texttt{0x41, 0x52, 0x41, 0x4d, 0x00, 0x00} & ???  \\ \hline
    ASHT & \texttt{0x41, 0x53, 0x48, 0x54, 0x00, 0x00} & ???  \\ \hline
    AUBI & \texttt{0x41, 0x44, 0x42, 0x49, 0x00, 0x00} & ???  \\ \hline
  \end{tabular}\\

\end{center}
NB - The table bytecodes are used in the resource block to enable a given resource in the gun 
environment; the actual value used to refer to the resource is dependent on its position in this
table.  (See section \ref{sec:resourcetable}).
	
\subsection{Sound constants}

\begin{center}
  \begin{tabular}{ | c | c || c | }
    \hline
    Source symbol & Table bytecode & Description \\ \hline \hline
    ASSIST\_BACKINGAME & \texttt{0x53, 0x44, 0x30, 0x32, 0x00, 0x00} & ???  \\ \hline
    ASSIST\_BASE1 & \texttt{0x53, 0x44, 0x30, 0x39, 0x00, 0x00} & ???  \\ \hline
    ASSIST\_BASE2 & \texttt{0x53, 0x44, 0x31, 0x30, 0x00, 0x00} & ???  \\ \hline
    ASSIST\_BASE3 & \texttt{0x53, 0x44, 0x31, 0x31, 0x00, 0x00} & ???  \\ \hline
    ASSIST\_BASE4 & \texttt{0x53, 0x44, 0x31, 0x32, 0x00, 0x00} & ???  \\ \hline    
    ASSIST\_SCANAMMO & \texttt{0x53, 0x44, 0x31, 0x33, 0x00, 0x00} & ???  \\ \hline
    ASSIST\_SCANLIFE & \texttt{0x53, 0x44, 0x31, 0x34, 0x00, 0x00} & ???  \\ \hline
    ASSIST\_UBICONNECT & \texttt{0x53, 0x44, 0x31, 0x35, 0x00, 0x00} & ???  \\ \hline
    BIP & \texttt{0x53, 0x43, 0x30, 0x32, 0x00, 0x00} & ???  \\ \hline
    DEAD & \texttt{0x53, 0x44, 0x30, 0x33, 0x00, 0x00}  & ???  \\ \hline
    EMPTY & \texttt{0x53, 0x57, 0x32, 0x32, 0x00, 0x00} & ???  \\ \hline
    HURT & \texttt{0x53, 0x43, 0x30, 0x35, 0x00, 0x00} & "Ungh"  \\ \hline
	OK & \texttt{0x53, 0x43, 0x31, 0x30, 0x00, 0x00} & "OK!"  \\ \hline	
    RELOAD & \texttt{0x53, 0x57, 0x31, 0x32, 0x00, 0x00} & ???  \\ \hline
	RELOAD\_CLIP & \texttt{0x53, 0x57, 0x34, 0x32, 0x00, 0x00} & ???  \\ \hline
	RESPAWN & \texttt{0x53, 0x43, 0x30, 0x37, 0x00, 0x00} & ???  \\ \hline	
	SC11 & \texttt{0x53, 0x43, 0x31, 0x31, 0x00, 0x00} & ???  \\ \hline      
	SCAN\_BAD & \texttt{0x53, 0x43, 0x30, 0x38, 0x00, 0x00} & ???  \\ \hline
    SCAN\_GOOD & \texttt{0x53, 0x43, 0x30, 0x39, 0x00, 0x00} & ???  \\ \hline
    SG01 & \texttt{0x53, 0x47, 0x30, 0x31, 0x00, 0x00} & ???  \\ \hline
    SG02 & \texttt{0x53, 0x47, 0x30, 0x32, 0x00, 0x00} & ???  \\ \hline
    SG03 & \texttt{0x53, 0x47, 0x30, 0x33, 0x00, 0x00} & ???  \\ \hline
    SG04 & \texttt{0x53, 0x47, 0x30, 0x34, 0x00, 0x00} & ???  \\ \hline  
    SHOOT & \texttt{0x53, 0x57, 0x35, 0x36, 0x00, 0x00} & "Pew"  \\ \hline
    START & \texttt{0x53, 0x43, 0x30, 0x33, 0x00, 0x00} & ???  \\ \hline
  \end{tabular}
\end{center}
NB - The table bytecodes are used in the resource block to enable a given resource in the gun 
environment; the actual value used to refer to the resource is dependent on its position in this
table.  (See section \ref{sec:resourcetable}).	


\section{Tables}
BTASM bytcode creates a number of tables on the device that are used during the game.  These are:
\begin{itemize}
\item The resource table
\item The variable table
\item (The function table)
\item (The state table)
\end{itemize}

The tables that are not parenthesized appear in the above order in the bytecode.  
The resource table must come first, followed immediately by the variable table.  The function
and state tables are generated from the \texttt{FUNCTION} and \texttt{STATE} commands.  They do
not appear as specific tables.

These tables all map from integers to the item at hand.  The table to be read from
at any given point is determined by the command being processed.  For example, a 
\texttt{SET}
command will read from the variable table, while a \texttt{GOTO} command will read from the
state table.

\subsection{Resource table}
\label{sec:resourcetable}
The resource table is the first item in a BTASM bytecode or source file.  It is formatted as 
follows:

\begin{itemize}
\item A byte containing the number of resources
\item A list of resource byte codes
\end{itemize}
\begin{figure}[h]
\begin{lstlisting}
<number of resources>
<bytecode for first resource>
<bytecode for second resource>
...
<bytecode for final resource>
\end{lstlisting}
\caption{Layout of a resource table} 
\end{figure}

The byte codes for specific resources can be found in the 
Within in the program, resources are referred to by their indices in the resource table.  The
location of each index in the table is determined by the order of resource bytecodes in the
table.  (See Figure~\ref{Resource table})
\begin{figure}[h]
\begin{lstlisting}
0x02,								-- 2 resources
0x53, 0x43, 0x30, 0x35, 0x00, 0x00, -- HURT
0x53, 0x43, 0x30, 0x33, 0x00, 0x00,	-- START
...
0xd0, 0x00, 0x06, 			-- function declaration 
							--   (6 bytes long)
0xc5, 0x00, 0x00,			-- SND HURT
0xc5, 0x01, 0x00,			-- SND START
--*end of function*
...
\end{lstlisting}
\caption{\label{Resource table} example code} 
\end{figure}

There are two types of resources: animation resources (begin with \texttt{A} in the BTASM source
language and \texttt{0x41} in the BTASM bytecode); and sound resources (begin with \texttt{0x53}
in the bytecode.  These can be added interchangeably in the resource table; animations must be
used with \texttt{ANIM}, while sounds must be used with \texttt{SND}.


\subsection{Variable table}
The variable table is created by a sequence of \texttt{VAR} commands at the 
\end{document}
